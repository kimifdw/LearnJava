# synchronized【重量级锁】
- 保证方法或者代码块在运行时，同一时刻只有一个方法进入到临界区
- 锁一旦升级为重量级锁，就不会再降级；JVM会尽量维持在低能耗锁
- 所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作
- 在很大的方法中声明synchronized，将大大影响效率。如果一定要使用synchronized关键字，可以用synchronized代码块代替synchronized方法。
- 以代码块来实现synchronized，常用`synchronized(this)`的方式
### 同步的基础
1. 对于同步方法，锁是当前**实例对象**
2. 对于静态同步方法，锁是当前对象的**class对象**
3. 对于同步方法块，锁是Synchonized*括号*里配置的对象
4. 同步方法的实质是将synchronized作用于**Object reference**。
5. java对象头。Mark Word（标记字段，用于存储对象自身的运行时数据）、Klass Pointer（类型指针，确定这个对象是哪个实例）  
6. monitor。线程私有的数据结构。
### 锁的四种状态
1. 无状态锁；
2. 偏向锁状态；
3. 轻量级锁状态；
4. 重量级锁状态；
### 自旋锁
1. 定义。让该线程等待一段时间（执行无意义的循环），不会被立即挂起，看持有锁的线程是否会很快释放锁。
2. 自旋等待不能代替阻塞
3. 通过参数-XX:preBlockSpin来调整自旋次数，默认10次，JDK1.6默认开启。
4. 适应自旋锁【JDK1.6】。自旋次数根据前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
### 偏向锁
1. 要解决的问题：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。
2. 锁的获得：测试对象头的Mark Word里是否存在存储着指向当前线程的偏向锁，如不存在，则再测试下Mark Word中偏向锁的标识是否为1，没有设置则使用CAS竞争锁；
3. 锁的撤销：需要等待全局安全点，它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，必须等到同步代码块执行完；
4. 关闭偏向锁：在java6和java7中默认启用，通过jvm参数关闭偏向锁：**UseBiasedLocking=false**，那么默认会进入**轻量级锁**状态；
5. 适用于**只有一个线程**访问同步块；
6. 偏向锁的耗能比轻量级锁少
### 轻量级锁
1. 加锁：线程在执行同步块前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。
2. 解锁：使用原子的CAS操作来讲Displaced Mark Word替换回到对象头；
3. 如果始终得不到锁竞争的线程使用自旋会消耗CPU;
4. 适用场景：追求响应时间；同步块执行速度非常快；
5. 性能提升的依据是"对于绝大部分的锁，在整个生命周期内都是不会存在竞争的"
### 重量级锁
1. 通过对象内部的监视器实现，本质是依赖于底层操作系统的Mutex Lock实现 
2. 线程竞争不使用自旋，不会消耗CPU；
3. 适用场景：追求吞吐量；同步块执行时间较长
### 锁消除。
1. 不存在共享数据竞争，会对同步锁进行锁消除。
2. 依据。逃逸分析的数据支持。
### 锁粗化。
1. 定义。将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。
### 同步机制。
通过给对象加锁实现的，为了防止同时访问共享资源。对于静态方法的同步会同步在类对象上，而实例方法是属于实例对象
### 同步目的。
保证写资源的唯一性。
### synchronized(this)
1. 当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
2. 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问object中的非synchronized(this)同步代码块。
3. 当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有**其他synchronized(this)同步代码块**得访问将被阻塞。
4. 当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其他线程对该object对象所有同步代码部分的访问都将被暂时阻塞。
### 注意点。
1. 无论synchronized加在方法上还是对象上，它取得的锁是**对象**，这里的对象是**调用这个同步方法**的对象。
2. 每个对象**只有一个锁**与之相关联。
3. 要尽量避免无谓的同步。
4. 没有明确的对象作为锁，可以创建一个特殊的instance对象。`private byte[] lock = new byte[0]；`
5. 定义private的instance变量+它的get方法，而**不要**定义public/protected的instance变量。如果将变量定义为public，对象在外界可以绕过同步方法的控制而直接取得它，并改动它.
6. 如果instance变量是一个对象，如数组或ArrayList什么的，那上述方法仍然不安全，因为当外界对象通过get方法拿到这个instance对象的引用后，又将其指向另一个对象，那么这个private变量也就变了，岂不是很危险。 这个时候就需要将get方法也加上synchronized同步，并且，只返回这个private对象的clone()――这样，调用端得到的就是对象副本的引用了
7. `synchronized(Foo.class)`等同于`public synchronized static void methodAAA()`，取得的锁是当前调用这个方法的对象所属的类，而不是这个类产生的**某个具体对象**。
8. 对于同步的方法或代码块来说，必须获得对象锁才能够进入同步方法或代码块进行操作；
9. 如果采用method级的同步，则对象锁即为method所在的*对象*；如果是**静态方法**，对象锁即为method所在的*Class对象(唯一)*
10. 静态方法一定会同步，非静态方法需在**单例模式**下生效。