# 并发
## 术语定义
1. 共享变量：在多个线程之间能够被共享的变量。他们被存放在堆内存中，Volatile只作用于共享变量
2. 内存屏障(Memory Barriers)：是一组处理器指令，用于实现对内存操作的顺序限制；
3. 缓冲行(Cache line)：缓存中可以分配的最小存储单位。
4. 原子操作（Atomic operation）: 不可中断的一个或一系列操作；
5. 缓存行填充（cache line fill）：当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存；
6. 缓存命中（cache hit）：如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数；
7. 写命中(write hit): 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则将处理器这个操作数写回到内存；
8. 写缺失（write misses the cache)：一个有效的缓存行被写入到不存在的内存区域；
9. CAS(Compare and Swap): 比较并设置。
## volatile
1. 定义：java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。
2. 用于修饰在多线程环境下某一变量值的一致性；
3. 在LinkedTransferQueue中，使用了volatile，追加64字节提高并发编程性能；
## synchronized
- 锁一旦升级为重量级锁，就不会再降级；JVM会尽量维持在低能耗锁
1. 同步的基础
    1. 对于同步方法，锁是当前**实例对象**
    2. 对于静态同步方法，锁是当前对象的**class对象**
    3. 对于同步方法块，锁是Synchonized括号里配置的对象
2. 锁的四种状态
    1. 无状态锁；
    2. 偏向锁状态；
    3. 轻量级锁状态；
    4. 重量级锁状态；
3. 偏向锁
    1. 要解决的问题：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。
    2. 锁的获得：测试对象头的Mark Word里是否存在存储着指向当前线程的偏向锁，如不存在，则再测试下Mark Word中偏向锁的标识是否为1，没有设置则使用CAS竞争锁；
    3. 锁的撤销：需要等待全局安全点，它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，必须等到同步代码块执行完；
    4. 关闭偏向锁：在java6和java7中默认启用，通过jvm参数关闭偏向锁：**UseBiasedLocking=false**，那么默认会进入**轻量级锁**状态；
    5. 适用于只有一个线程访问同步块；
    6. 偏向锁的耗能比轻量级锁少
4. 轻量级锁
    1. 加锁：线程在执行同步块前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。
    2. 解锁：使用原子的CAS操作来讲Displaced Mark Word替换回到对象头；
    3. 如果始终得不到锁竞争的线程使用自旋会消耗CPU;
    3. 适用场景：追求响应时间；同步块执行速度非常快；
5. 重量级锁
    1. 线程竞争不使用自旋，不会消耗CPU；
    2. 适用场景：追求吞吐量；同步块执行时间较长
##
    

